/**
 * Class representing a single output of an AudioletNode
 *
 * @constructor
 * @param {AudioletNode} node The node which the input belongs to.
 * @param {Number} index The index of the input.
 */
var AudioletOutput = function(node, index) {
    this.node = node;
    this.index = index;
    this.connectedTo = [];
    // External buffer where data pulled from the graph is stored
    this.buffer = new AudioletBuffer(1, 0);
    // Internal buffer for if we are in a feedback loop
    this.feedbackBuffer = new AudioletBuffer(1, 0);
    // Buffer to shift data into if we are in a feedback loop
    this.outputBuffer = new AudioletBuffer(1, 0);

    this.linkedInput = null;
    this.numberOfChannels = 1;

    this.suppliesFeedbackLoop = false;
    this.timestamp = null;
};

/**
 * Connect the output to an input
 *
 * @param {AudioletInput} input The input to connect to.
 */
AudioletOutput.prototype.connect = function(input) {
    this.connectedTo.push(input);
};

/**
 * Disconnect the output from an input
 *
 * @param {AudioletInput} input The input to disconnect from.
 */
AudioletOutput.prototype.disconnect = function(input) {
    var numberOfStreams = this.connectedTo.length;
    for (var i = 0; i < numberOfStreams; i++) {
        if (input == this.connectedTo[i]) {
            this.connectedTo.splice(i, 1);
            break;
        }
    }
};

/**
 * Check whether the input is connected
 *
 * @return {Boolean} True if the output is connected.
 */
AudioletOutput.prototype.isConnected = function() {
    return (this.connectedTo.length > 0);
};

/**
 * Link the output to an input, forcing the output to always contain the
 * same number of channels as the input.
 *
 * @param {AudioletInput} input The input to link to.
 */
AudioletOutput.prototype.linkNumberOfChannels = function(input) {
    this.linkedInput = input;
};

/**
 * Unlink the output from its linked input
 */
AudioletOutput.prototype.unlinkNumberOfChannels = function() {
    this.linkedInput = null;
};

/**
 * Get the number of output channels, taking the value from the input if the
 * output is linked.
 *
 * @return {Number} The number of output channels.
 */
AudioletOutput.prototype.getNumberOfChannels = function() {
    if (this.linkedInput && this.linkedInput.isConnected()) {
        return (this.linkedInput.buffer.numberOfChannels);
    }
    return (this.numberOfChannels);
};

/**
 * Get the output buffer.  This is more complicated than it seems, as in
 * feedback loops we try to get data from the previous tick, which was often
 * a different length to the current tick.  In order to get round this we keepi
 * a fixed length FIFO buffer of the output and limit the size of blocks we
 * request to the size of the buffer.  This means that we never overflow the
 * buffer, so output data is always available.  The price we pay for this is
 * introducing extra latency equal to the length of the FIFO.
 *
 * @param {Number} length The number of samples requested.
 * @return {AudioletBuffer} The output buffer.
 */
AudioletOutput.prototype.getBuffer = function(length) {
    var buffer = this.buffer;
    if (buffer.length == length && !this.suppliesFeedbackLoop) {
        // Buffer not part of a feedback loop, so just return it
        return buffer;
    }
    else {
        // Buffer is part of a feedback loop, so we need to take care
        // of overflows.
        // Because feedback loops have to be connected to more than one
        // node, getBuffer will be called more than once.  To make sure
        // we only generate the output buffer once, store a timestamp.
        if (this.node.timestamp == this.timestamp) {
            // Buffer already generated by a previous getBuffer call
            return this.outputBuffer;
        }
        else {
            this.timestamp = this.node.timestamp;

            var feedbackBuffer = this.feedbackBuffer;
            var outputBuffer = this.outputBuffer;

            if (!this.suppliesFeedbackLoop) {
                this.suppliesFeedbackLoop = true;
                var limiter = this.node.audiolet.blockSizeLimiter;
                feedbackBuffer.resize(this.getNumberOfChannels(),
                                      limiter.maximumBlockSize, true);
            }

            // Resize feedback buffer to the correct number of channels
            feedbackBuffer.resize(this.getNumberOfChannels(),
                                  feedbackBuffer.length);

            // Resize output buffer to the correct size
            outputBuffer.resize(this.getNumberOfChannels(), length, true);

            // Buffer the output, so nodes on a later timestamp (i.e. nodes
            // in a feedback loop connected to this output) can pull
            // any amount up to maximumBlockSize without fear of overflow
            feedbackBuffer.push(buffer);
            feedbackBuffer.shift(outputBuffer);

            return outputBuffer;
        }
    }
};

/**
 * toString
 *
 * @return {String} String representation.
 */
AudioletOutput.prototype.toString = function() {
    return this.node.toString() + 'Output #' + this.index + ' - ';
};

